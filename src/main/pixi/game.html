<!DOCTYPE HTML>
<html>
<head>
<title>pixi.js example 1</title>
<link rel="stylesheet" href="resources/bootstrap/css/bootstrap.min.css" />
<link rel="stylesheet" href="resources/bootstrap/css/bootstrap-theme.min.css" />
<style>
body {
	margin: 0;
	padding: 0;
	background-color: black;
}

.text {
	color: white;
}

.center {
    display: table;
    margin: 0 auto;
}

#response_div .text {
    margin: 0 0 5px 0;
}
</style>
<script src="resources/pixi.js"></script>
<script src="resources/jquery.min.js"></script>
<script src="resources/bootstrap/js/bootstrap.min.js"></script>
<script src="js/keypress.js"></script>
<script src="js/actor.js"></script>
<script src="js/levels.js"></script>
<script src="js/dialog.js"></script>
<script src="js/prop.js"></script>
</head>
<body>

    <div class="center">
    	<div id="game_div"></div>
    	<div class="text">
    		<div id="response_div"></div>
    		<div id="choices_div"></div>
    	</div>
    </div>

	<script type="text/javascript">
	// some static information about the world
	var WORLD = {
			WIDTH:  960,
			HEIGHT: 540,
			FLOOR:  400,
			STEP_DURATION:   16,
			PREVIOUS_UPDATE: -1,
			AGENT:    null,
			TEXTURES:   {},
			GROUNDS:    {},
			MOVEMENT: 'world',
			PROGRESS: {
				show_library: false,
				questions: [],
			},
	};
	
	function getTexture(name) {
		if(!(name in WORLD.TEXTURES))
			WORLD.TEXTURES[name] = PIXI.Texture.fromImage("assets/"+name+".png");
		return WORLD.TEXTURES[name];
	}
	
	(function() {
		// create an new instance of a pixi stage
		var stage = new PIXI.Stage(0x0);

		var grayFilter = new PIXI.GrayFilter();
		
		// create two different containers to add onScreenObjects into
		WORLD.GROUNDS.skybox     = new PIXI.DisplayObjectContainer();
		WORLD.GROUNDS.background = new PIXI.DisplayObjectContainer();
		WORLD.GROUNDS.staticforeground = new PIXI.DisplayObjectContainer();
		WORLD.GROUNDS.foreground = new PIXI.DisplayObjectContainer();
		stage.addChild(WORLD.GROUNDS.skybox);
		stage.addChild(WORLD.GROUNDS.background);
		stage.addChild(WORLD.GROUNDS.staticforeground);
		stage.addChild(WORLD.GROUNDS.foreground);
		stage.filters = [grayFilter];
		
		var mountain = new PIXI.TilingSprite(getTexture("mountain"), 3600, 400);
		mountain.position.x = -1200;
		WORLD.GROUNDS.background.addChild(mountain);
		
		// when the agent moves, we move the foreground and background in the opposite direction
		// things that are farther away move slower
	 	keydown_left  = function() {
			WORLD.AGENT.state.velocity  = 4;
			WORLD.AGENT.state.direction = 1;
			clearDialog();
		};
		keydown_right = function() {
			WORLD.AGENT.state.velocity  = -4;
			WORLD.AGENT.state.direction = -1;
			clearDialog();
		};
		keyup_left  = function() { WORLD.AGENT.state.velocity = 0; };
		keyup_right = function() { WORLD.AGENT.state.velocity = 0; };

		// create a renderer instance
		// TODO make a note that: if you are using chrome and running from a file system, the security policy won't let you load images
		// - to get around this, use firefox, or use a hoted version
		var renderer = new PIXI.WebGLRenderer(WORLD.WIDTH, WORLD.HEIGHT);
		
		// create the sky
		var theskyyyy = new PIXI.Sprite(getTexture("THE_SKYYYYYYYYY"));
		theskyyyy.anchor.x = 0.5;
		theskyyyy.anchor.y = 0.5;
		theskyyyy.position.x = WORLD.WIDTH / 2;
		theskyyyy.position.y = WORLD.HEIGHT + 260;
		WORLD.GROUNDS.skybox.addChild(theskyyyy);

        // create the sun
		var thesun = new PIXI.Sprite(getTexture("sun"));
		thesun.anchor.x = 0.5;
		thesun.anchor.y = 0.5;
		thesun.position.x = WORLD.WIDTH / 2;
		thesun.position.y = -80;
		thesun.radius = Math.abs(theskyyyy.position.y) + Math.abs(thesun.position.y);
		WORLD.GROUNDS.skybox.addChild(thesun);

        var themoon = new PIXI.Sprite(getTexture("moon"));
        themoon.anchor.x = 0.5;
        themoon.anchor.y = 0.5;
        themoon.radius = thesun.radius - 75;
        themoon.position.x = WORLD.WIDTH / 2;
        themoon.position.y = theskyyyy.position.y + themoon.radius;
        WORLD.GROUNDS.skybox.addChild(themoon);

		// add the renderer view element to the DOM
		$("#game_div").append(renderer.view);
		
		var onScreenObjects = [];
		
		WORLD.AGENT = createAgent(stage, WORLD.WIDTH/2);
		keyInteract = function() {
			// find an element that is near the player
		    for(i in onScreenObjects) {
		    	if(onScreenObjects[i] && onScreenObjects[i].interact) {
			    	// get the distance between the elements and the agent
			    	var dist = Math.abs(onScreenObjects[i].getStageX() - WORLD.AGENT.getStageX());
			    	if(dist < WORLD.AGENT.base.width/2)
			    		onScreenObjects[i].interact();
		    	}
		    }
		};

		keydown_jump = function() {
			//press space to jump
			WORLD.AGENT.state.doJump = true
		};

		loadMainstreet(onScreenObjects);
		function updateStep() {
		    theskyyyy.rotation -= 0.0005;
		    thesun.position.x   = thesun.radius  * Math.cos(theskyyyy.rotation) + theskyyyy.position.x;
		    thesun.position.y   = thesun.radius  * Math.sin(theskyyyy.rotation) + theskyyyy.position.y;
            themoon.position.x  = themoon.radius * Math.cos(theskyyyy.rotation+Math.sin(theskyyyy.rotation*0.15+2)*0.50+Math.PI) + theskyyyy.position.x;
            themoon.position.y  = themoon.radius * Math.sin(theskyyyy.rotation+Math.sin(theskyyyy.rotation*0.15+0)*0.25+Math.PI) + theskyyyy.position.y;
		    WORLD.AGENT.update();
		    if(WORLD.MOVEMENT == "player")
		    	WORLD.AGENT.setX(WORLD.AGENT.getX() - (WORLD.AGENT.state.velocity+WORLD.AGENT.state.jump_velocity));
		    else if(WORLD.MOVEMENT == "world") {
			    WORLD.GROUNDS.foreground.position.x += (WORLD.AGENT.state.velocity + WORLD.AGENT.state.jump_velocity);
			    WORLD.GROUNDS.background.position.x += (WORLD.AGENT.state.velocity+WORLD.AGENT.state.jump_velocity)/2;
		    }
		    
		    grayFilter.gray = 1 - WORLD.AGENT.state.mood;
		    for(i in onScreenObjects)
		    	if(onScreenObjects[i].update)
			    	onScreenObjects[i].update();
		}
		
		// the animation step is called whenever the screen is supposed to draw
		// but we don't know how much time has passed
		// we may want to change the update more than once because enough time has passes (or not update at all)
		function animate() {
		    requestAnimFrame( animate );

			// get the current time
			var currTime = new Date().getTime();
			// did we actually updatethis time?
			var updated = false;
			
			if(WORLD.PREVIOUS_UPDATE < 0) {
				// this is the first time we called, so we only need to update once
				updateStep();
				WORLD.PREVIOUS_UPDATE = currTime;
			} else {
				// calculate the ellapsed time
				var ellapsed = currTime - WORLD.PREVIOUS_UPDATE;
				
				// run the update step as many times as needed
				while(ellapsed >= WORLD.STEP_DURATION) {
					updateStep();
					WORLD.PREVIOUS_UPDATE = currTime;
					ellapsed -= WORLD.STEP_DURATION;
				}
			}
			
		    // render the stage   
		    renderer.render(stage);
		}
		
		requestAnimFrame( animate );
	}());
	</script>
</body>
</html>
