<!DOCTYPE HTML>
<html>
<head>
<title>pixi.js example 1</title>
<style>
body {
	margin: 0;
	padding: 0;
	background-color: black;
}

.text {
	color: white;
}
</style>
<script src="resources/pixi.js"></script>
<script src="resources/jquery.min.js"></script>
<script src="js/keypress.js"></script>
<script src="js/actor.js"></script>
<script src="js/levels.js"></script>
<script src="js/dialog.js"></script>
</head>
<body>

	<div id="game_div"></div>
	<div class="text">
		<div id="response_div"></div>
		<div id="choices_div"></div>
	</div>

	<script type="text/javascript">
	// some static information about the world
	var WORLD = { WIDTH:960, HEIGHT:540, FLOOR:400, STEP_DURATION:16, PREVIOUS_UPDATE:-1, AGENT:null };
	
	(function() {
		// create an new instance of a pixi stage
		var stage = new PIXI.Stage(0x66FF99);

		var grayFilter = new PIXI.GrayFilter();
		
		// create two different containers to add onScreenObjects into
		var background = new PIXI.DisplayObjectContainer();
		var foreground = new PIXI.DisplayObjectContainer();
		var skybox     = new PIXI.DisplayObjectContainer();
		stage.addChild(skybox);
		stage.addChild(background);
		stage.addChild(foreground);
		stage.filters = [grayFilter];
		
		// when the agent moves, we move the foreground and background in the opposite direction
		// things that are farther away move slower
	 	keyLeft  = function() {
			foreground.position.x += 16;
			background.position.x += 8;
			clearDialog();
		};
		keyRight = function() {
			foreground.position.x -= 16;
			background.position.x -= 8;
			clearDialog();
		};

		// create a renderer instance
		// TODO make a note that: if you are using chrome and running from a file system, the security policy won't let you load images
		// - to get around this, use firefox, or use a hoted version
		var renderer = new PIXI.WebGLRenderer(WORLD.WIDTH, WORLD.HEIGHT);
		
		// create the ground
		var ground = new PIXI.Sprite(PIXI.Texture.fromImage("assets/ground.png"));
		ground.width = WORLD.WIDTH;
		ground.position.y = WORLD.FLOOR;
		stage.addChild(ground);

		// create the sky
		var theskyyyy = new PIXI.Sprite(PIXI.Texture.fromImage("assets/THE_SKYYYYYYYYY.png"));
		theskyyyy.anchor.x = 0.5;
		theskyyyy.anchor.y = 0.5;
		theskyyyy.position.x = WORLD.WIDTH / 2;
		theskyyyy.position.y = WORLD.HEIGHT + 260;
		skybox.addChild(theskyyyy);

		var thesun = new PIXI.Sprite(PIXI.Texture.fromImage("assets/sun.png"));
		thesun.anchor.x = 0.5;
		thesun.anchor.y = 0.5;
		thesun.position.x = WORLD.WIDTH / 2;
		thesun.position.y = -80;
		thesun.radius = Math.abs(theskyyyy.position.y) + Math.abs(thesun.position.y);
		skybox.addChild(thesun);

		// add the renderer view element to the DOM
		$("#game_div").append(renderer.view);
		
		var onScreenObjects = [];
		
		loadMainstreet(background, foreground, onScreenObjects);
		WORLD.AGENT = createAgent(stage, WORLD.WIDTH/2);
		keyInteract = function() {
			// find an element that is near the player
		    for(i in onScreenObjects) {
		    	if(onScreenObjects[i].interact) {
			    	// get the distance between the elements and the agent
			    	var dist = Math.abs(onScreenObjects[i].getStageX() - WORLD.AGENT.getStageX());
			    	if(dist < WORLD.AGENT.base.width/2)
			    		onScreenObjects[i].interact();
		    	}
		    }
		};
		
		function updateStep() {
		    theskyyyy.rotation -= 0.01;
		    thesun.position.x = thesun.radius * Math.cos(theskyyyy.rotation) + theskyyyy.position.x;
		    thesun.position.y = thesun.radius * Math.sin(theskyyyy.rotation) + theskyyyy.position.y;
		    WORLD.AGENT.update();
		    grayFilter.gray = 1 - WORLD.AGENT.state.mood;
		    for(i in onScreenObjects)
		    	onScreenObjects[i].update();
		}
		
		// the animation step is called whenever the screen is supposed to draw
		// but we don't know how much time has passed
		// we may want to change the update more than once because enough time has passes (or not update at all)
		function animate() {
		    requestAnimFrame( animate );

			// get the current time
			var currTime = new Date().getTime();
			// did we actually updatethis time?
			var updated = false;
			
			if(WORLD.PREVIOUS_UPDATE < 0) {
				// this is the first time we called, so we only need to update once
				updateStep();
				WORLD.PREVIOUS_UPDATE = currTime;
			} else {
				// calculate the ellapsed time
				var ellapsed = currTime - WORLD.PREVIOUS_UPDATE;
				
				// run the update step as many times as needed
				while(ellapsed >= WORLD.STEP_DURATION) {
					updateStep();
					WORLD.PREVIOUS_UPDATE = currTime;
					ellapsed -= WORLD.STEP_DURATION;
				}
			}
			
		    // render the stage   
		    renderer.render(stage);
		}
		
		requestAnimFrame( animate );
	}());
	</script>
</body>
</html>
